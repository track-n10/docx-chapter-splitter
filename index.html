<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOCX Chapter Splitter - Client-Side Version</title>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --success: #4cc9f0;
            --warning: #f8961e;
            --danger: #e63946;
            --light: #f8f9fa;
            --dark: #212529;
            --gray: #6c757d;
            --light-gray: #e9ecef;
            --electron-blue: #47848f;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            color: var(--light);
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            background: rgba(0, 0, 0, 0.4);
            color: white;
            padding: 2rem 0;
            text-align: center;
            border-radius: 15px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(to right, #4facfe, #00f2fe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 700px;
            margin: 0 auto;
        }

        .version-notice {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            padding: 2rem;
            margin-bottom: 2rem;
            transition: transform 0.3s ease;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.12);
        }
        
        .card-title {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            color: var(--success);
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #b0bec5;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        
        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-label {
            display: block;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            text-align: center;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-input-label:hover {
            background: rgba(0, 0, 0, 0.4);
            border-color: var(--primary);
        }
        
        .file-name {
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--success);
            font-style: italic;
        }
        
        textarea {
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            min-height: 150px;
            resize: vertical;
        }
        
        textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }
        
        .btn {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        .btn-success {
            background: linear-gradient(135deg, var(--success), #2a9d8f);
        }
        
        .progress-bar {
            height: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 15px;
        }
        
        .progress {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--success));
            width: 0;
            transition: width 0.5s ease;
            border-radius: 10px;
        }
        
        .chapter-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 25px;
            margin-top: 1.5rem;
        }
        
        .chapter-card {
            background: rgba(0, 0, 0, 0.25);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s, box-shadow 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .chapter-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
        }
        
        .chapter-header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 20px;
            position: relative;
        }
        
        .chapter-title {
            font-size: 1.3rem;
            margin: 0;
        }
        
        .chapter-number {
            position: absolute;
            top: 10px;
            right: 15px;
            background: rgba(0, 0, 0, 0.3);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.2rem;
        }
        
        .chapter-content {
            padding: 25px;
            max-height: 250px;
            overflow-y: auto;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            background: rgba(0, 0, 0, 0.15);
        }
        
        .chapter-actions {
            padding: 20px;
            display: flex;
            justify-content: space-between;
        }
        
        .copy-alert {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--success);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            transform: translateX(200%);
            transition: transform 0.4s ease;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .copy-alert.show {
            transform: translateX(0);
        }
        
        footer {
            text-align: center;
            padding: 2rem 0 1rem;
            color: var(--gray);
            font-size: 0.95rem;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            margin-top: 2rem;
        }
        
        @media (max-width: 768px) {
            .chapter-list {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 10px;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-book-open"></i> DOCX Chapter Splitter</h1>
            <p class="subtitle">Client-Side Version - Process documents entirely in your browser</p>
            <div class="version-notice">
                <strong>âš¡ Browser-Only Processing:</strong> Your documents never leave your computer - all processing happens locally in your browser!
            </div>
        </header>
        
        <div class="card">
            <h2 class="card-title"><i class="fas fa-file-upload"></i> Upload & Process Document</h2>
            
            <div class="form-group">
                <label for="docx-file">Select a DOCX file</label>
                <div class="file-input-wrapper">
                    <input type="file" id="docx-file" accept=".docx">
                    <div class="file-input-label">
                        <i class="fas fa-cloud-upload-alt"></i> Drag & drop or click to select DOCX file
                    </div>
                </div>
                <div id="file-name" class="file-name">No file selected</div>
            </div>
            
            <div class="form-group">
                <label for="chapter-summary">Chapter Titles (one per line)</label>
                <textarea id="chapter-summary" placeholder="Enter chapter titles, one per line:

Example:
Introduction
Chapter 1: Getting Started
Chapter 2: Advanced Features
Chapter 3: Best Practices
Conclusion

Tips:
â€¢ Try different formats: 'Chapter 1', 'CHAPTER 1', '1.', etc.
â€¢ Use exact titles as they appear in your document
â€¢ Check if your document has a table of contents"></textarea>
            </div>
            
            <div class="form-group">
                <label>
                    <input type="checkbox" id="auto-detect" style="margin-right: 8px;">
                    Try automatic chapter detection (if titles don't work)
                </label>
            </div>
            
            <button id="process-btn" class="btn">
                <i class="fas fa-cogs"></i> Process Document in Browser
            </button>
            
            <div style="margin-top: 20px;">
                <p id="status-text">No document loaded</p>
                <div class="progress-bar">
                    <div id="progress" class="progress"></div>
                </div>
            </div>
        </div>
        
        <div class="card" id="debug-section" style="display: none;">
            <h2 class="card-title"><i class="fas fa-bug"></i> Processing Information</h2>
            <div id="debug-info" style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; font-family: monospace; font-size: 0.9rem;">
                <!-- Debug information will be shown here -->
            </div>
        </div>
        
        <div class="card" id="results-section" style="display: none;">
            <h2 class="card-title"><i class="fas fa-book"></i> Generated Chapters</h2>
            <div class="chapter-list" id="chapter-list">
                <!-- Chapters will be dynamically added here -->
            </div>
        </div>
    </div>
    
    <div class="copy-alert" id="copy-alert">
        <i class="fas fa-check-circle"></i> Content copied to clipboard!
    </div>
    
    <footer class="container">
        <p>DOCX Chapter Splitter - Client-Side Version | Your documents are processed locally and never uploaded to any server</p>
    </footer>

    <!-- Include DOCX processing libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <script>
        let processedChapters = [];
        let currentFile = null;
        
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('docx-file');
            const fileNameDisplay = document.getElementById('file-name');
            const dropArea = document.querySelector('.file-input-label');
            
            fileInput.addEventListener('change', function() {
                if (this.files.length > 0) {
                    currentFile = this.files[0];
                    fileNameDisplay.textContent = currentFile.name;
                    updateStatus('Document loaded, ready for processing');
                    updateProgress(10);
                } else {
                    currentFile = null;
                    fileNameDisplay.textContent = 'No file selected';
                    updateProgress(0);
                }
            });
            
            // Drag and drop functionality
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight() {
                dropArea.style.borderColor = '#4361ee';
                dropArea.style.backgroundColor = 'rgba(67, 97, 238, 0.1)';
            }
            
            function unhighlight() {
                dropArea.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                dropArea.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
            }
            
            dropArea.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0 && files[0].name.endsWith('.docx')) {
                    fileInput.files = files;
                    currentFile = files[0];
                    fileNameDisplay.textContent = files[0].name;
                    updateStatus('Document loaded, ready for processing');
                    updateProgress(10);
                } else {
                    alert('Please select only .docx files');
                }
            }
            
            document.getElementById('process-btn').addEventListener('click', processDocument);
        });
        
        function updateProgress(percentage) {
            document.getElementById('progress').style.width = `${percentage}%`;
        }
        
        function updateStatus(text) {
            document.getElementById('status-text').textContent = text;
        }
        
        async function processDocument() {
            if (!currentFile) {
                alert('Please select a DOCX file first.');
                return;
            }
            
            const summary = document.getElementById('chapter-summary').value.trim();
            if (!summary) {
                alert('Please enter chapter titles.');
                return;
            }
            
            const chapterTitles = summary.split('\n')
                .map(title => title.trim())
                .filter(title => title.length > 0);
            
            if (chapterTitles.length === 0) {
                alert('Please enter at least one chapter title.');
                return;
            }
            
            try {
                updateStatus('Processing document in your browser...');
                updateProgress(30);
                
                const arrayBuffer = await currentFile.arrayBuffer();
                const result = await mammoth.convertToHtml({ arrayBuffer: arrayBuffer });
                
                updateProgress(60);
                updateStatus('Splitting into chapters...');
                
                const html = result.value;
                const chapters = splitDocumentIntoChapters(html, chapterTitles);
                
                processedChapters = chapters;
                
                // Show debug information
                showDebugInfo(chapters, chapterTitles);
                
                renderChapters(processedChapters);
                
                updateProgress(100);
                updateStatus(`Document processed successfully! ${chapters.length} chapters created.`);
                
                document.getElementById('debug-section').style.display = 'block';
                document.getElementById('results-section').style.display = 'block';
                
                setTimeout(() => {
                    const message = `Document processed successfully!\n${chapters.length} chapters were created.\n\nDetection method: ${chapters.detectionMethod || 'Unknown'}\n\nNote: This browser version outputs HTML format. For DOCX downloads, use the full version on Railway.`;
                    alert(message);
                }, 300);
                
            } catch (error) {
                console.error('Processing error:', error);
                updateStatus('Error processing document');
                updateProgress(0);
                alert('Error processing document. Please ensure it\'s a valid DOCX file.');
            }
        }
        
        function splitDocumentIntoChapters(html, chapterTitles) {
            console.log('Starting document splitting...');
            console.log('Chapter titles:', chapterTitles);
            console.log('HTML length:', html.length);
            
            // First, try to find chapter breaks by titles
            const chapterBreaks = findChapterBreaks(html, chapterTitles);
            console.log('Found chapter breaks:', chapterBreaks);
            
            if (chapterBreaks.length > 1) {
                // Found multiple breaks, split accordingly
                const chapters = splitByBreaks(html, chapterTitles, chapterBreaks);
                chapters.detectionMethod = `Found ${chapterBreaks.length} chapter breaks by title matching`;
                return chapters;
            } else {
                // Try automatic detection if enabled
                const autoDetect = document.getElementById('auto-detect').checked;
                if (autoDetect) {
                    console.log('Trying automatic chapter detection...');
                    const autoChapters = tryAutomaticDetection(html, chapterTitles.length);
                    if (autoChapters && autoChapters.length > 1) {
                        autoChapters.detectionMethod = 'Automatic chapter detection by patterns';
                        return autoChapters;
                    }
                }
                
                // If no automatic detection or failed, return entire document as one chapter
                const fallbackChapters = [{
                    title: chapterTitles[0] || 'Complete Document',
                    content: html,
                    originalIndex: 0
                }];
                fallbackChapters.detectionMethod = 'Fallback: Using entire document as single chapter';
                return fallbackChapters;
            }
        }
        
        function findChapterBreaks(html, chapterTitles) {
            const breaks = [];
            const lowercaseHtml = html.toLowerCase();
            
            // Try to find each chapter title in the HTML
            chapterTitles.forEach((title, index) => {
                const searchPatterns = generateSearchPatterns(title);
                
                for (const pattern of searchPatterns) {
                    const regex = new RegExp(pattern, 'gi');
                    let match;
                    
                    while ((match = regex.exec(html)) !== null) {
                        // Check if this is likely a heading (not just text in paragraph)
                        const beforeText = html.substring(Math.max(0, match.index - 100), match.index);
                        const afterText = html.substring(match.index + match[0].length, Math.min(html.length, match.index + match[0].length + 100));
                        
                        // Look for heading patterns or structural elements
                        if (isLikelyHeading(beforeText, afterText, match[0])) {
                            breaks.push({
                                index: match.index,
                                title: title,
                                foundText: match[0],
                                chapterIndex: index
                            });
                            break; // Found this chapter, move to next
                        }
                    }
                }
            });
            
            // Sort by position in document
            breaks.sort((a, b) => a.index - b.index);
            
            // Remove duplicates (keep first occurrence)
            const uniqueBreaks = [];
            const seenTitles = new Set();
            
            for (const brk of breaks) {
                if (!seenTitles.has(brk.title)) {
                    uniqueBreaks.push(brk);
                    seenTitles.add(brk.title);
                }
            }
            
            return uniqueBreaks;
        }
        
        function generateSearchPatterns(title) {
            const patterns = [];
            const cleanTitle = title.trim();
            
            // Exact match with word boundaries
            patterns.push(`\\b${escapeRegex(cleanTitle)}\\b`);
            
            // Without punctuation
            const noPunct = cleanTitle.replace(/[^\w\s]/g, '').trim();
            if (noPunct !== cleanTitle) {
                patterns.push(`\\b${escapeRegex(noPunct)}\\b`);
            }
            
            // Try with different case patterns
            patterns.push(`\\b${escapeRegex(cleanTitle.toUpperCase())}\\b`);
            patterns.push(`\\b${escapeRegex(cleanTitle.toLowerCase())}\\b`);
            
            // Try without "Chapter" word if present
            const withoutChapter = cleanTitle.replace(/^chapter\s*/i, '').trim();
            if (withoutChapter !== cleanTitle) {
                patterns.push(`\\b${escapeRegex(withoutChapter)}\\b`);
            }
            
            return patterns;
        }
        
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function isLikelyHeading(beforeText, afterText, matchText) {
            // Check for HTML heading tags
            if (/<h[1-6][^>]*>.*$/i.test(beforeText) && /^.*<\/h[1-6]>/i.test(afterText)) {
                return true;
            }
            
            // Check for paragraph with strong emphasis
            if (/<p[^>]*><strong[^>]*>.*$/i.test(beforeText) && /^.*<\/strong><\/p>/i.test(afterText)) {
                return true;
            }
            
            // Check for bold text
            if (/<b[^>]*>.*$/i.test(beforeText) && /^.*<\/b>/i.test(afterText)) {
                return true;
            }
            
            // Check if text is at beginning of paragraph
            if (/<p[^>]*>.*$/i.test(beforeText)) {
                const afterMatch = afterText.substring(0, 50);
                // If followed by paragraph end or line break, likely a heading
                if (/<\/p>|<br\s*\/?>/i.test(afterMatch)) {
                    return true;
                }
            }
            
            // Check for surrounding whitespace patterns (indicating standalone text)
            const textBefore = beforeText.replace(/<[^>]*>/g, '').trim();
            const textAfter = afterText.replace(/<[^>]*>/g, '').trim();
            
            if (textBefore.length === 0 || textBefore.endsWith('\n') || textBefore.endsWith('.')) {
                if (textAfter.length === 0 || textAfter.startsWith('\n') || /^[\s\n]/.test(textAfter)) {
                    return true;
                }
            }
            
            return false;
        }
        
        function splitByBreaks(html, chapterTitles, breaks) {
            const chapters = [];
            
            if (breaks.length === 0) {
                return [{
                    title: 'Complete Document',
                    content: html,
                    originalIndex: 0
                }];
            }
            
            // Add the first section (before first chapter)
            if (breaks[0].index > 0) {
                const beforeContent = html.substring(0, breaks[0].index).trim();
                if (beforeContent.length > 100) { // Only add if substantial content
                    chapters.push({
                        title: 'Introduction/Preface',
                        content: beforeContent,
                        originalIndex: -1
                    });
                }
            }
            
            // Split between chapter breaks
            for (let i = 0; i < breaks.length; i++) {
                const currentBreak = breaks[i];
                const nextBreak = breaks[i + 1];
                
                const startIndex = currentBreak.index;
                const endIndex = nextBreak ? nextBreak.index : html.length;
                
                const chapterContent = html.substring(startIndex, endIndex).trim();
                
                if (chapterContent.length > 50) { // Only add chapters with substantial content
                    chapters.push({
                        title: currentBreak.title,
                        content: chapterContent,
                        originalIndex: currentBreak.chapterIndex,
                        foundText: currentBreak.foundText
                    });
                }
            }
            
            return chapters;
        }
        
        function tryAutomaticDetection(html, expectedChapterCount) {
            console.log('Attempting automatic chapter detection...');
            
            // Try to find patterns that might indicate chapters
            const headingPatterns = [
                /<h[1-3][^>]*>([^<]+)<\/h[1-3]>/gi,
                /<p[^>]*><strong[^>]*>([^<]+)<\/strong><\/p>/gi,
                /<p[^>]*><b[^>]*>([^<]+)<\/b><\/p>/gi
            ];
            
            const potentialChapters = [];
            
            for (const pattern of headingPatterns) {
                let match;
                while ((match = pattern.exec(html)) !== null) {
                    const title = match[1].trim();
                    
                    // Filter out likely non-chapter headings
                    if (title.length > 3 && title.length < 100 && 
                        !title.toLowerCase().includes('table of contents') &&
                        !title.toLowerCase().includes('index') &&
                        !/^\d+$/.test(title)) { // Not just a number
                        
                        potentialChapters.push({
                            title: title,
                            index: match.index,
                            fullMatch: match[0]
                        });
                    }
                }
            }
            
            // Remove duplicates and sort
            const uniqueChapters = [];
            const seenTitles = new Set();
            
            for (const chapter of potentialChapters) {
                if (!seenTitles.has(chapter.title.toLowerCase())) {
                    uniqueChapters.push(chapter);
                    seenTitles.add(chapter.title.toLowerCase());
                }
            }
            
            uniqueChapters.sort((a, b) => a.index - b.index);
            
            console.log('Found potential chapters:', uniqueChapters);
            
            // If we found a reasonable number of chapters, use them
            if (uniqueChapters.length >= 2 && uniqueChapters.length <= expectedChapterCount * 2) {
                return splitByAutomaticBreaks(html, uniqueChapters);
            }
            
            return null;
        }
        
        function splitByAutomaticBreaks(html, chapters) {
            const result = [];
            
            for (let i = 0; i < chapters.length; i++) {
                const current = chapters[i];
                const next = chapters[i + 1];
                
                const startIndex = current.index;
                const endIndex = next ? next.index : html.length;
                
                const content = html.substring(startIndex, endIndex).trim();
                
                if (content.length > 100) {
                    result.push({
                        title: current.title,
                        content: content,
                        originalIndex: i
                    });
                }
            }
            
            return result;
        }
        
        function showDebugInfo(chapters, originalTitles) {
            const debugDiv = document.getElementById('debug-info');
            let debugText = `Original titles provided: ${originalTitles.length}\n`;
            debugText += `Chapters created: ${chapters.length}\n`;
            debugText += `Detection method: ${chapters.detectionMethod || 'Unknown'}\n\n`;
            
            debugText += 'Chapter breakdown:\n';
            chapters.forEach((chapter, index) => {
                debugText += `${index + 1}. "${chapter.title}" (${chapter.content.length} chars)\n`;
                if (chapter.foundText) {
                    debugText += `   Found as: "${chapter.foundText}"\n`;
                }
            });
            
            debugText += '\nOriginal titles:\n';
            originalTitles.forEach((title, index) => {
                debugText += `${index + 1}. "${title}"\n`;
            });
            
            debugDiv.textContent = debugText;
        }
        
        function renderChapters(chapters) {
            const chapterList = document.getElementById('chapter-list');
            chapterList.innerHTML = '';
            
            chapters.forEach((chapter, index) => {
                const chapterCard = document.createElement('div');
                chapterCard.className = 'chapter-card';
                
                // Truncate content for preview
                const contentPreview = chapter.content.length > 500 
                    ? chapter.content.substring(0, 500) + '...' 
                    : chapter.content;
                
                chapterCard.innerHTML = `
                    <div class="chapter-header">
                        <h3 class="chapter-title">${escapeHtml(chapter.title)}</h3>
                        <div class="chapter-number">${index + 1}</div>
                    </div>
                    <div class="chapter-content">
                        ${contentPreview}
                    </div>
                    <div class="chapter-actions">
                        <button class="btn btn-success" onclick="copyChapter(${index})">
                            <i class="fas fa-copy"></i> Copy HTML
                        </button>
                        <button class="btn" onclick="downloadChapter(${index})">
                            <i class="fas fa-download"></i> Download
                        </button>
                    </div>
                `;
                
                chapterList.appendChild(chapterCard);
            });
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function copyChapter(index) {
            const chapter = processedChapters[index];
            if (chapter) {
                navigator.clipboard.writeText(chapter.content).then(() => {
                    showCopyAlert();
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = chapter.content;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showCopyAlert();
                });
            }
        }
        
        function downloadChapter(index) {
            const chapter = processedChapters[index];
            if (chapter) {
                const blob = new Blob([chapter.content], { type: 'text/html;charset=utf-8' });
                const filename = `${chapter.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.html`;
                saveAs(blob, filename);
            }
        }
        
        function showCopyAlert() {
            const alert = document.getElementById('copy-alert');
            alert.classList.add('show');
            setTimeout(() => {
                alert.classList.remove('show');
            }, 3000);
        }
    </script>
</body>
</html>
